# CD Pipeline: Database Migration → Build → Deploy
#
# Trigger:
#   - Push to main: Auto-deploy to dev (only changed components)
#   - Manual (workflow_dispatch): Select environment and components
#
# Flow:
#   1. detect-changes: Determine which components changed
#   2. migrate: Run database migrations (if API changed)
#   3. deploy-api: Build and deploy API to ECS (if API changed)
#   4. deploy-web: Build and deploy Web to S3/CloudFront (if Web changed)
#
# Authentication:
#   - AWS OIDC (no long-lived credentials)
#   - RDS IAM Authentication (no stored DB passwords)
#
# Required GitHub Environments: dev, stg, prd
#
# Environment Variables (set per environment):
#   - AWS_REGION: AWS region (e.g., ap-northeast-1)
#   - AWS_ROLE_ARN: IAM Role ARN for OIDC authentication
#   - DB_HOST, DB_PORT, DB_DBNAME, DB_USERNAME: Database connection
#   - ECR_REPOSITORY_API, CONTAINER_NAME_API: ECR settings
#   - ECS_SERVICE_API, ECS_CLUSTER: ECS settings
#   - S3_BUCKET_WEB, CLOUDFRONT_DISTRIBUTION_ID: Frontend settings

name: CD

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stg
          - prd
      deploy_api:
        description: 'Deploy API'
        type: boolean
        default: true
      deploy_web:
        description: 'Deploy Web'
        type: boolean
        default: true

# Prevent concurrent deployments to same environment
concurrency:
  group: cd-${{ inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  GO_VERSION: '1.25'

jobs:
  # ====================
  # Setup & Change Detection
  # ====================
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      deploy_api: ${{ steps.changes.outputs.api }}
      deploy_web: ${{ steps.changes.outputs.web }}
      deploy_db: ${{ steps.changes.outputs.db }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for change detection

      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ inputs.environment }}" >> "$GITHUB_OUTPUT"
          else
            echo "environment=dev" >> "$GITHUB_OUTPUT"
          fi

      - name: Detect changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual dispatch: use input values
            echo "api=${{ inputs.deploy_api }}" >> "$GITHUB_OUTPUT"
            echo "web=${{ inputs.deploy_web }}" >> "$GITHUB_OUTPUT"
            echo "db=${{ inputs.deploy_api }}" >> "$GITHUB_OUTPUT"
          else
            # Push: detect changed files
            API_CHANGED=$(git diff --name-only HEAD~1 HEAD | grep -q '^apps/api/' && echo 'true' || echo 'false')
            WEB_CHANGED=$(git diff --name-only HEAD~1 HEAD | grep -q '^apps/web/' && echo 'true' || echo 'false')
            DB_CHANGED=$(git diff --name-only HEAD~1 HEAD | grep -q '^apps/pkgs/db/' && echo 'true' || echo 'false')

            echo "api=$API_CHANGED" >> "$GITHUB_OUTPUT"
            echo "web=$WEB_CHANGED" >> "$GITHUB_OUTPUT"
            echo "db=$DB_CHANGED" >> "$GITHUB_OUTPUT"

            echo "::notice::API changed: $API_CHANGED, Web changed: $WEB_CHANGED, DB changed: $DB_CHANGED"
          fi

  # ====================
  # Database Migration
  # ====================
  migrate:
    name: Migrate (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy_db == 'true' || needs.setup.outputs.deploy_api == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - uses: ./.github/actions/aws-auth
        with:
          role-arn: ${{ vars.AWS_ROLE_ARN }}
          region: ${{ vars.AWS_REGION }}

      - name: Generate RDS auth token
        id: rds-token
        run: |
          TOKEN=$(aws rds generate-db-auth-token \
            --hostname ${{ vars.DB_HOST }} \
            --port ${{ vars.DB_PORT }} \
            --username ${{ vars.DB_USERNAME }} \
            --region ${{ vars.AWS_REGION }})
          echo "::add-mask::$TOKEN"
          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: Setup Atlas
        uses: ariga/setup-atlas@v0

      - name: Run database migration
        env:
          DB_HOST: ${{ vars.DB_HOST }}
          DB_PORT: ${{ vars.DB_PORT }}
          DB_DBNAME: ${{ vars.DB_DBNAME }}
          DB_USERNAME: ${{ vars.DB_USERNAME }}
          DB_PASSWORD: ${{ steps.rds-token.outputs.token }}
        working-directory: apps/pkgs/db
        run: atlas migrate apply --env ci

  # ====================
  # Deploy API
  # ====================
  deploy-api:
    name: Deploy API (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, migrate]
    if: |
      always() &&
      needs.setup.outputs.deploy_api == 'true' &&
      (needs.migrate.result == 'success' || needs.migrate.result == 'skipped')
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - uses: ./.github/actions/aws-auth
        with:
          role-arn: ${{ vars.AWS_ROLE_ARN }}
          region: ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/api/.images/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY_API }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY_API }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Render ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .aws/task-definition-api.json
          container-name: ${{ vars.CONTAINER_NAME_API }}
          image: ${{ steps.login-ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY_API }}:${{ github.sha }}

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ vars.ECS_SERVICE_API }}
          cluster: ${{ vars.ECS_CLUSTER }}
          wait-for-service-stability: true

  # ====================
  # Deploy Web
  # ====================
  deploy-web:
    name: Deploy Web (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy_web == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: apps/web/go.mod

      - name: Build WASM
        working-directory: apps/web
        run: |
          GOOS=js GOARCH=wasm go build -o static/main.wasm .
          cp "$(go env GOROOT)/lib/wasm/wasm_exec.js" ./static/
          echo "Build complete:"
          ls -lh static/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Deploy to S3
        working-directory: apps/web/static
        run: |
          # Sync all files with appropriate cache headers
          aws s3 sync . s3://${{ vars.S3_BUCKET_WEB }}/ \
            --delete \
            --exclude "*.html" \
            --cache-control "public, max-age=31536000, immutable"

          # Upload HTML files with no-cache
          aws s3 sync . s3://${{ vars.S3_BUCKET_WEB }}/ \
            --exclude "*" \
            --include "*.html" \
            --cache-control "no-cache, no-store, must-revalidate" \
            --content-type "text/html"

      - name: Invalidate CloudFront cache
        run: |
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          echo "::notice::CloudFront invalidation created: $INVALIDATION_ID"
